
# множества и кортежи

# что такое множество 
# синтаксис и основные свойства множеств
# что такое кортеж, основные свойства кортежа
# цикл while

# множества(set)  - изменяемый тип данных, который представяет собой
# неупорядоченную коллекцию уникальных элементов. 
# ОНИ изменяемы, неупорядоченны и уникальны

# МНОЖЕСТВА SET МОЖНО СОЗДАТЬ НЕСКОЛЬКИМИ МЕТОДАМИ. 
# САМЫЙ ПРОСТОЙ ИЗ НИХ ЭТО ЗАДАТЬ МНОЖЕСТВО ПУТЕМ ПЕРЕЧИСЛЕНИЯ
# ЕГО ЭЛЕМЕНТОВ ВНУТРИ ФИГУРНЫХ СКОБОК.

# set1 = {1,2,3}
# print(type(set1))

# ОДНАКО НЕЛЬЗЯ СОЗДАВАТЬ ПУСТОЕ СНОЖЕСТВО, ТАК КАК ОНО СОЗДАСТ
# ПУСТОЙ СЛОВАРЬ

# set1 = {}
# print(type(set1))

# А ЧТОБЫ СОЗДАТЬ ПУСТОЕ МНОЖЕСТВО НЕОБХОДИМО ИСПОЛЬЗОВАТЬ
# ФУНКЦИЮ SET 

# set1 = set()
# print(type(set1))

# свойства множеств
# неупорядоченны. Порядок расположения элементов в множестве
# не имеет значения. А это значит, они не индексируются и не поддерживают 
# операции срезов или же получения индекса по срезу

# изменяемость.
# множества изменяемы и поддердживают 
# обьединение множеств
# добавление элементов
# удаление элементов

# УНИКАЛЬНОСТЬ
# МНОЖЕСТВА ДОЛЖНЫ БЫТЬ УНИКАЛЬНЫМИ А ЭТО ЗНАЧИТ ОНО НЕ МОДЕТ СОДЕРЖАТЬ 
# ОДИНАКОВЫХ ЭЛЕМЕНТОВ

# САМО ПО СЕБЕ МНОЖЕСТВО НЕИЗМЕНЯМЫ И ЕГО МОЖНО МЕНЯТЬ.
# ОДНАКО ЭЛЕМЕНТЫ МНОЖЕСТВА ЯВЛЯЮТСЯ НЕИЗМЕННЫМИ, ОТНОСЯТСЯ
# К НЕИЗМЕНЯЕМЫМ ТИПАМ ДАННЫХ

# ГДЕ ИСПОЛЬЗУЮТСЯ МНОЖЕСТВА
# ЕСЛИ НАМ НУЖНО ПОЛУЧИТЬ УНИКАЛЬНОЕ ЗНАЧЕНИЕ КОТОРОЕ НЕ ПОВТОРЯЕТСЯ

# МЕЖДУ МНОЖЕСТВАМИ МОГУТ БЫТЬ НЕСКОЛЬКО СВЯЗЕЙ ИЛИ ОТНОШЕНИЙ
# 1. РАВНЫЕ МНОЖЕСТВА. 
# ТАК НАЗЫВАЮТСЯ ПОТОМУ ЧТО МОГУТ ИМЕТЬ ДВА МНОЖЕСТВА С 
# ОДИНАКОВЫМИ ЭЛЕМЕНТАМИ
# 2. НЕПЕРСЕКАЮЩИЕСЯ МНОЖЕСТВА
# ТАК ГОВОРЯТ КОГДА МНОЖЕСТВА НЕ ИМЕЮТ ОДИНАКОВЫХ ЭЛЕМЕНТОВ
# 3. ПОДМНОЖЕСТВА И НАДМНОЖЕСТВА

# В ЯЗЫКЕ ПАЙТОН СУЩЕСТВУЮЕТ ТИП ДАННЫХ
# С ХАРАКТЕРИСТИКАМИ МНОЖЕСТВА
# НО С НЕБОЛЬШИМ ОТЛИЧИЕМ А ИМЕННО СВОЙСТВОМ НЕИЗМЕНЯЕМОСТИ
# ТАКОЙ ТИП ДАННЫХ НАЗЫВ. ЗАМОРОЖЕННОЕ МНОЖЕСТВО ИЛИ frozenset
# frozenset - НЕИЗМЕНЯЕМЫЙ ТИП ДАННЫХ С ХАРАКТЕРИСТИКАМИ МНОЖЕСТВА
# ЗАЧЕМ НАМ НУЖЕН FROZENSET
# ЭТОТ ТИП ДАННЫХ ИСП НЕ ТАК ЧАСТО ВМЕСТО НЕГО ИСПОЛЬЗУЮТ КОРТЕЖ

# TUPLE = УПОРЯДОЧЕННЫЙ ТИП ДАННЫХ КОТОРЫЙ НЕИЗМЕНЯЕТСЯ И ПРЕДСТАВЛЯЕТ 
# ПОСЛЕДОВАТЕЛЬНОСТЬ ЭЛЕМЕНТОВ
  
# ЦИКЛ WHILE  ПОКА 
# ЭТО УНИВЕРСАЛЬНЫЙ ЦИКЛ ЕГО СИНТАКСИС ИДЕТ ТАК

# while True_or_False_expression:
#     do_something

# похож на оператор if

# В while  ПОТОК ВОЗВРАЩАЕТСЯ К ЗАГОЛОВКУ ЦИКЛА И СНОВА ПРОВЕРЯЕТ 
# УСЛОВИЕ. ЕСДИ ЛОГИЧЕСКОЕ ВЫРАЖЕНИЕ ВОЗВРАЩАЕТ True ТО ЦИКЛ
# СНОВА ВЫПОЛНЯЕТСЯ ДО ТЕХ ПОР ПОКА ЛОГИЧЕСКОЕ ВЫРАЖЕНИЕ НЕ ВЫДАСТ False

# с циклом используются опервторы break и continue
# break ДАЕТ ВОЗМОЖНОСТЬ ВЫЙТИ ИЗ ЦИКЛА ПРИ СРАБАТЫВАНИИ 
# ВНЕШНЕГО УСЛОВИЯ
# ПОМЕЩАЕМ ОПРЕТОР BREAK ПОД ОПЕРВТОРОМ WHILE.
# ОБЫЧНО ПОСЛЕ УСЛОВНОГО ОПЕРВТОРА IF
# И ОПЕРАТОР BREAK ПРИВОДИТ К ВЫХОДУ ИЛИ РАЗРЫВУ ИЗ ЦИКЛА

# ОПЕРАТОР CONTINUE
# ДАЕТ ВОЗМОЖНОСТЬ ПРОПУСТИТЬ ЧАСТЬ ЦИКЛА В КОТОРЫЙ СРАБАТЫВАЕТ 
# ВНЕШНИЕ УСЛОВИЯ НО ПОЗВОЛЯЕТ ПРОДОЛЖИТЬ ВЫПОЛНЕНИЯ ЦИКЛА ДО КОНЦА


# empty = set()
# print(type(empty))

# a = {'makers', 4, 9, True, False}
# b = set('makers')
# print(a)
# c = set(range(1,10,2))
# print(c)

# set1 = {'hello', 2, True, [1,2,3]}
# print(set1)

# СПИСОК, СЛОВАРЬИ САМО МНОЖЕСТВО НЕ МОЖЕТ БЫТЬ ВНУТРИ МНОЖЕСТВА ТАК КАК ОНИ ТАКЖЕ ЯВЛЯЮТСЯ
# ИЗМЕНЯЕМЫМИ

# СРАНЕНИЕ МНОЖЕСТВ
# set1 = {1,5,3,9,8}
# set2 = {9,1,5,3,8}
# set3 = {1,5,1,3,3,8,8,8,9,9}
# print(set1 == set2)
# print(set3)
# print(set3 == set2)

# set1 = {1, 1.0, True}   что было вначале то и выводит так как они все равны
# print(set1)

# set3 = {1,5,1,3,3,8,8,8,9,9}   
# print(len(set3))               дает только колво уникальных элементов работает также и со строками




# set1 = {1,2,3,(1,2,3, [1]), 's'}
# print(set1)  # -- unhashable type: 'list'


# Добавление элементов

# add(element)
# apdate(sequence)

# my_set = {1,2,3}
# my_set.add(3)
# my_set.add('hello')
# my_set.add({1,2,3}) # -- unhashable tupe: 'set'
# print(my_set)


# my_set = {1,2}
# my_set.update([1,2,3,4])
# my_set.update({3:'1', 2:"2"})
# my_set.update('string', [1,2,3,4,5])
# print(my_set)


# Удаление элементов

# clear()
# my_set.clear()


# remove() - удаляет элемент, если такого элемента нет, то выдает ошибку

# my_set = {1,2}
# my_set.remove(2)
# my_set.remove(4) # --- KeyError: 4



# discard() - удаляет элемент, если элемента нет то ничего не происходит

# my_set = {1,2}
# my_set.discard(2)
# my_set.discard(4)



# pop() - удаляет случайный элемент из set() и возвращает

# set2 = {1,2,3,2,4,5}
# popped = set2.pop()
# print(popped)



# difference() - 

# set_a.difference(set_b) - выводит элементы которые есть в set_a  но нет в set_b
# set_a - set_b

# set1 = {1,2,3}
# set2 = {3,4,5}
# print(set1 - set2)  # {1,2}
# print(set1.difference(set2))  # {1,2}



# symmetric_difference() - выводит элементы которые уникальны в обоих множествах
# set_a ^ set_b

# a = {1,2,3,4,5}
# b = {5,6,7,8,9}
# print(a ^ b) # --- {1,2,3,4,6,7,8,9}
# print(a.symmetric_difference(b)) # --- {1,2,3,4,6,7,8,9}



# intersection - выводит похожие элементы из set_a и set_b
# set_a & set_b

# a = {1,2,3,4,5}
# b = {5,6,7,8,9}
# print(a & b) # --- {5}
# print(a.intersection(b)) # --- {5}



# union - соединяет множества
# set_a | set_b

# a = {1,2,3,4,5}
# b = {5,6,7,8,9}
# ab = (a.union(b))
# print(a | b)
# print(a.union(b))
# print(ab)

# my_set = {1,2,3,4}
# my_list = [5,6,7,8] == (5,6,7,8)
# res = my_set.union(my_list)
# print(my_set | my_list) # --- unsupported operand type(s) for |: 'set' and 'list'
# print(res)




# Число 1 соответствует первому множеству в списке a, число 2 второму, а 3 третьему.

# В зависимости от переданного числа, сохраните строку в inp1, в одно из пустых множеств внутри списка a. В остальные множества добавьте строку "default value".

# В конце, выведите получившийся список.

# Например, если пользователь ввел Hello world и 1, то вывод:

# a = [set(), set(), set()] 
# inp1 = input() 
# inp2 = int(input()) 
# i = 0 
# if inp2 == 1: 
#     a[inp2 - 1].update([inp1]) 
#     a[inp2].update(['default value']) 
#     a[inp2 + 1].update(['default value']) 
# elif inp2 == 2: 
#     a[inp2 - 1].update([inp1]) 
#     a[inp2 - 2].update(['default value']) 
#     a[inp2].update(['default value']) 
# elif inp2 == 3: 
#     a[inp2 - 1].update([inp1]) 
#     a[inp2 - 3].update(['default value']) 
#     a[inp2 - 2].update(['default value']) 
# else: 
#     a[0].update(['default value']) 
#     a[1].update(['default value']) 
#     a[2].update(['default value']) 
# print(a)

